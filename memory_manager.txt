.$ Бестиповый C$ (не типизированный), 32-bit's (x86, или i386). В скором времени – расширение до 64-bit's (x86_64).
.$ Организация менеджера памяти было создано так, что память почти не расходуется в пустую, при этом полностью исключена фрагментация (провалы в памяти).
.$ Единственным недостатком тут является затрачиваемые ресурсы (их размер постоянно растёт, в следствии чего, скрипт начинает раздувать), когда запрашивается память с новым диапазоном данных (15/34/654 и т.д. символов).
<$
   Данная директива задействует 5'000 байт статической памяти под весь скрипт
   Из неё же будет доступно выделение динамической памяти (в т.ч. для служебной информации менеджера памяти)
$>
#reserve_memory 5'000b или 5Kb  .$ после компиляции будет создан массив на 5'000 ячеек типа byte (он же char)

struct Player или sample Player
{
    programming_language[20]    .$ количество байт фиксированной длины
    <$ programming_language[?]  .$ количество байт переменной длины $>
};
Player player[1'000];  .$ количество байт фиксированной длины
<$ Player player[?];   .$ количество байт переменной длины $>

ExecuteScript()
{
    ptr = request_memory 3b;
    ptr[0] = C; .. равносильно *(ptr+0), он же ptr
    ptr[1] = $; .. равносильно *(ptr+1)
    ptr[2] = '\0'; .. можно просто EOS, макрос который преобразуется в '\0', равносильно *(ptr+2)
    free_up_memory ptr;
    player[0].programming_language = C$";
    .$ player[0].programming_language = request_memory 20b;
    .$ free_up_memory player[0].programming_language;
    return;
}
<$
    << 1. Использование оператора request_memory приводит к тому что, менеджер памяти создаёт в таблице служебную информацию. >>
    << 2. В первую очередь, создаётся виртуальный регистр, который может работать с ячейками памяти равными 3 байта.  >>
    << 3. Таким образом, менеджер памяти сможет очень быстро и эффективно находить свободное место под использование (смещение указателя происходит по 3 байта). >>
    << 4. Сам регистр займёт место в 4 байта и будет указывать на свободную ячейку памяти. >>
    << 5. Когда запрашивается память (при её доступности), регистр смещается на указанный диапазон (длину), указывая на свободное место в памяти. >>
    << 6. Использование оператора free_up_memory освобождает память, когда она больше не нужна. >>
    << 7. Если использовать оператор request_memory и по окончании не использовать free_up_memory ptr, произойдёт утечка памяти. >>
$>
