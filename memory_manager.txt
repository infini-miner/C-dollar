.. Бестиповый C$ (не типизированный), 32-bit's (x86, или i386). В скором времени – расширение до 64-bit's (x86_64).
<$
    Данная директива задействует 5 байт статической памяти под весь скрипт
    Из неё же будет доступно выделение динамической памяти (в т.ч. для служебной информации менеджера памяти)
$>
#reserve_memory 5b .. после компиляции будет создан массив на 5 ячеек типа byte (он же char)
.. << use memory, allocate memory, engage memory, free up memory, request memory, occupy memory >>

ExecuteScript()
{
    ptr = request_memory 5b;
    ptr[0] = C; .. равносильно *(ptr+0), он же ptr
    ptr[1] = $; .. равносильно *(ptr+1)
    ptr[2] = '\0'; .. можно просто EOS, макрос который преобразуется в '\0', равносильно *(ptr+2)
    free_up_memory ptr;
    return;
}

<$
    << 1. Использование оператора request_memory приводит к тому что, менеджер памяти создаёт в таблице служебную информацию. >>
    << 2. В первую очередь, создаётся виртуальный регистр, который может работать с ячейками памяти равными 5 байт.  >>
    << 3. Таким образом, менеджер памяти сможет очень быстро и эффективно находить свободное место под использование (смещение указателя происходит по 5 байт). >>
    << 4. Сам регистр займёт место в 4 байта и будет указывать на свободную ячейку памяти. >>
    << 5. Когда запрашивается память (при её доступности), регистр смещается на указанный диапазон (длину), указывая на свободное место в памяти. >>
    << 6. Использование оператора free_up_memory освобождает память, когда она больше не нужна. >>
$>
