.. Бестиповый C$ (не типизированный)
<$
    Данная директива задействует 5 байт статической памяти под весь скрипт
    Из неё же будет доступно выделение динамической памяти (в т.ч. для служебной информации менеджера памяти)
$>
# reserve_memory 5b .. после компиляции будет создан массив на 5 ячеек типа byte (он же char)
.. << use memory, allocate memory, engage memory, free up memory, request memory, occupy memory >>

ExecuteScript()
{
    ptr = use_memory 5b;
    ptr[0] = C; .. равносильно *(ptr+0), он же ptr
    ptr[1] = $; .. равносильно *(ptr+1)
    ptr[2] = '\0'; .. можно просто EOS, макрос который преобразуется в '\0', равносильно *(ptr+2)
    return;
}

<$
    << 1. Использование оператора use_memory приводит к тому что, менеджер памяти создаёт в таблице служебную информацию >>
    << 2. В первую очередь, создаётся виртуальный регистр, который может работать с ячейками равными 5 байт  >>
    << 3. Таким образом, менеджер памяти сможет очень быстро и эффективно находить свободное место под использование (смещение указателя происходит по 5 байт) >>
    << 4. Сам регистр займёт место в 4 байта и будет указывать на свободную ячейку памяти >>
$>
